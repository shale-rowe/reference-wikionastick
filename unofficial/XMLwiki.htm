<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">




<!--
Icons taked from:
http://jimmac.musichall.cz/i.php?i=gorilla-stock

Saving/loading routines taken from:
http://www.tiddlywiki.com/

License:

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the Osmosoft Limited nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

-->







<head>



	<meta name="author" content="andre" />
	<meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" />
	
	



	<!--   CSS	-->
<style type="text/css">/* background */
body {
    background-color: #FAFAFA;
}

/* page title */
p.title {
  font-size: 22pt;
  font-weight: bold;
  margin-bottom: 0pt;
  margin-top: 0pt;
}

/* Text */
/*
.text_area {
  font-family: "Arial";
} */

/* Left menu */
div.menu_area {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  font-size: 9pt;
  background-color: white;
  padding: 5pt;
  width: 80pt;
}

/* Main text */
div.text_area {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  background-color: white;
  padding: 10pt;
}
	
/* existent link */
a.link {
  color: blue;
}
a.link:hover {
  text-decoration: underline;
  cursor:pointer;
}

/* unexistent link */
a.unlink {
  color: red;
}
a.unlink:hover {
  text-decoration: underline;
  cursor:pointer;
}

/* outside world link */
a.world {
  color: darkgreen;
  text-decoration: underline;
}
a.world:hover {
  cursor:pointer;
}

/* Tables */
table.text_area {
  border-color: black;
  border-spacing: 0px;
  border-style: solid;
  border-width: 1px;
}

table.text_area td
{
  border-width: 1px;
  border-style: solid;
  padding: 5px;
}
</style>
<!-- End CSS code -->







<!-- JAVASCRIPT -->

<script type="text/javascript">
<![CDATA[

var debug = true;            // won't save if it's true

var editing = false;         // 0 = editing, 1 = viewing
var current;                 // currently loaded page
var backstack = new Array(); // back button stack
var forstack = new Array();  // forward button stack

// Browser
var ie = false;
var firefox = false;
var opera = false;
var unsupported_browser = true;

// Returns the element by ID
function el(name)
{
	return document.getElementById(name);
}

// Returns a page variable (variables names end with a '_')
function get_var(name)
{
	var pages = el("variables").childNodes;
	name = name + "_";
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
			if(pages[i].id.toUpperCase() == name.toUpperCase())
				return pages[i].innerHTML;
	}
	return false;
}

// Sets a page variable
function set_var(name, value)
{
	name = name + "_";
	var pages = el("variables").childNodes;
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
			if(pages[i].id.toUpperCase() == name.toUpperCase())
			{
				pages[i].innerHTML = value;
				return;
			}
	}
}

// Recieves a visible page name and returns a valid name
function valid_name(invalid)
{
	invalid = escape(invalid);
	// alert("Valid: " + invalid);
	return invalid;
}

// Recieves a valid name and returns a visible name
function visible_name(valid)
{
	valid = unescape(valid);
	// alert("Visible: " + valid);
	return valid;
}

// Returns if a page exists
function page_exists(page)
{
	page = valid_name(page);
	if(page.match("Special%3A%3A")) // TODO - only at beginning
		return true;
	var pages = el("wiki").childNodes;
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
			if(pages[i].id.toUpperCase() == page.toUpperCase())
				return true;
	}
	return false;
}



/// The TextStream class takes a block of text, and
/// allows it to be accessed as a stream, using
/// next(), and peek()
function TextStream(text){
	this.text = text;
	this.loc = 0;
	this.next = function(){
		if(this.loc >= this.text.length){
			return null;
		}
		var c = this.text.charAt(this.loc);
		this.loc = this.loc+1;
		return c;
	}
	this.peek = function(){
		if(this.loc >= this.text.length){
			return null;
		}
		return this.text.charAt(this.loc);
	}
}


// I was thinking of looking around for a parser generator to create a parser
// for wikitext, but I decided that the language is simple enough to write a
// parser by hand.  Just to avoid future confusion, I specified in the name.

//Basically, it works like this:
// you give it a block of text, and it creates a TextStream of the block.
// The parse method calls parseNormal, which just does not text transformations,
// and simply returns the text it was able to parse whenever it hits a special
// character.
// parse then calls parseSpecial to handle the special character
// parseSpecial calls the appropriate specialized parser, which are almost all
// functions that recurse on parseNormal and parseSpecial, allowing all kinds
// of nesting of parsers.
// parseXML does not allow nesting
function HandWrittenParser(text){
	this.validate = false;
	this.stream = new TextStream(text);
	this.result = ""
	// a list of special sequences.  Parse normal
	// returns when it encounters any of them
	this.specials = ["*","_","/","\n","!","+","#","[","]", "<", ">","\\", "-", "{", "|"];
 
	this.isSpecial = function(c){
		for(var i=0;i<this.specials.length;i++){
			if(this.specials[i]==c){
				return true;
			}
		}
		return false;
	}

	this.addText = function(cl){
		this.result += cl;
	}

	// parseNormal scans the text, adding
	// all "normal" characters to the result
	// and returning whenever it get a special
	// character
	this.parseNormal = function(){
		var c;
		var ret = "";
		while( (c = this.stream.peek())!=null){
			
			if(this.isSpecial(c)){
				break;
			}
			ret+=this.stream.next();
		}
		return ret;
	}


	this.parseUntil= function(stopChars){
		var body = ""
		do{
			body += this.parseNormal();
			if(stopChars.match(this.stream.peek())!=null){
				break;
			}else if(this.stream.peek()!=null){
				// recurse onto a different special element
				body=body+this.parseSpecial();
			}else{
				break;
			}
		}while(this.stream.peek()!=null);
		return body;
	}

	//parse header: see how many header levels we have
	this.parseHeader = function(){
		var lvl = 2;
		var body = ""
		while(this.stream.peek() == "!"){
			lvl++;
			this.stream.next();
		}
		
		// now we know what kind of header we have
		// we want to continuously run parsenormal
		// until we get to a newline to end it

		do{
			body += this.parseNormal();
			// we don't want to eat up the newline, because
			// it may be needed to end other tags.
			// however, if we don't, it gets caught by
			// parseSpecial, and the page looks like ass
			if(this.stream.peek()=="\n"){
				this.stream.next();
				break;
			}else if(this.stream.peek()!=null){
				// recurse onto a different special element
				body=body+this.parseSpecial();
			}else{
				break;
			}
		}while(this.stream.peek()!=null);
		return "<h"+lvl+">"+body+"</h"+lvl+">";
	}

	//Parse a bullet list
	//FIXME: this produces "dirty" output, each list element is
	//it's own list, so they are separated by newlines in the rendered
	//output.
	this.parseList = function(endChar, tag){
		var lvl = 1;
		var body = ""
		var startTag = "<"+tag+"><li>";
		var endTag = "</li><\/"+tag+">";
		while(this.stream.peek() == endChar){
			lvl++;
			startTag = "<"+tag+">"+startTag;
			endTag = endTag +"<\/"+tag+">";
			this.stream.next();
		}
		do{
			body += this.parseNormal();
			// we don't want to eat up the newline, because
			// it may be needed to end other tags.
			// however, if we don't, it gets caught by
			// parseSpecial, and the page looks like ass
			if(this.stream.peek()=="\n"){
				this.stream.next();
				break;
			}else if(this.stream.peek()!=null){
				// recurse onto a different special element
				body=body+this.parseSpecial();
			}else{
				break;
			}
		}while(this.stream.peek()!=null);
		body = startTag+body+endTag;
		return body;
	}

	this.parseTypesetting = function(endChar, tag){
		var body="";
		var start = this.stream.loc;
		do{
			body += this.parseNormal();
			if(this.stream.peek() ==endChar){
				this.stream.next();
				break;
			}else if(this.stream.peek()==null){
				if(this.validate){
					alert("Unmatched tag started at character "+start+
						"\nExpected \""+endChar+"\"");
					throw start;
				}
				break;
			}
			body += this.parseSpecial();
		}while(1);
		var ret = "<"+tag+">"+body+"<\/"+tag+">";
		return ret;
	}

	this.parseEscape = function(){
		var c = this.stream.next();
		if(c!=null){
			return "&#"+c.charCodeAt(0)+";";
		}else{
			return ""
		}
	}

	this.parseLink = function(){
		var text = "";
		var target = "";
		var texting = true;		
		
		//ensure that we started with two brackets:
		if((text=this.stream.next())!="["){
			return "["+text;
		}
		text=""
		
		//in this case, we don't want to recurse.  All text
		// within the link should be taken literally.

		while(1){
			var c = this.stream.next()
			if(c=="|"){
				c="";
				texting = false;
			}else if(c=="]"){
				if(this.stream.peek() == "]"){
					this.stream.next();
					break;
				}
			}else if(c=="\""){
				c=this.parseEscape();
			}
			if(texting){
				text+=c;
			}else{
				target+=c;
			}
		}

		if(texting){

			if(text.match("://")){
				text= "<a class=\"world\" href=\"" + text 
					+ "\" target=\"_blank\">" + text + "<\/a>";
			}
			else if(page_exists(text)){
				text = "<a class=\"link\" onclick='go_to(\"" 
					+ valid_name(text) +"\")'>" + text + "<\/a>";
			}else{
				text ="<a class=\"unlink\" onclick='go_to(\"" 
					+ valid_name(text) +"\")'>" + text + "<\/a>";
			}
		}else{
			if(target.match("://")){
				text= "<a class=\"world\" href=\"" + target 
					+ "\" target=\"_blank\">" + text + "<\/a>";
			}
			else if(page_exists(target)){
				text = "<a class=\"link\" onclick='go_to(\"" 
					+ valid_name(target) +"\")'>" + text + "<\/a>";
			}else{
				text ="<a class=\"unlink\" onclick='go_to(\"" 
					+ valid_name(target) +"\")'>" + text + "<\/a>";
			}
		}
		return text;
	}		

	this.parseXML = function(){
		text ="<";
		var c;
		do{
			c = this.stream.next();
			if(c==null){
				break;
			}
			text += c;
		}while(c!=">");
		return text;
	}
		
	this.parseHorizontalRule = function(){
		var text = "-";
		var c = this.stream.next();
		text +=c;
		if(c!="-"){
			return text;
		}
		c = this.stream.next();
		text +=c;
		if(c!="-"){
			return text;
		}
		return "<hr \/>"
	}

	this.parseTableData = function(){
		var ret = "";
		var data = ""		

		while(this.stream.peek() !="\n"){
			data += this.parseNormal();
			if(this.stream.peek() == null 
					|| this.stream.peek()=="\n"){
				if(data!=""){
					ret+= "<td>"+data+"<\/td>";
				}
				data = "";
				break;
			}
			if(this.stream.peek() == "|"){
				this.stream.next();
				//not a double bar:
				// accept the input and keep going
				if(this.stream.peek() != "|"){
					data+="|";
					continue;
				}
				this.stream.next();
				ret+= "<td>"+data+"<\/td>";
				data ="";
			}else{
				data += this.parseSpecial();
			}
		}
		if(data!=""){
			ret+= "<td>"+data+"<\/td>";
		}
		return ret;
	}

	this.parseTable = function(){
		var ret = "{"+this.stream.next();
		if(ret!= "{|"){
			return ret;
		}
		ret = "<table class=\"text_area\" ";
		var c;
		var firstRow = true;
		var attr="";
		// entire line following table opening
		// is xml code for table attributes, do not parse
		do{
			c = this.stream.peek();
			if(c==null){
				break;
			}
			if(c=="\n"){
				break;
			}
			attr += this.stream.next();
		}while(c!="\n");
		ret += attr+">";
		//Now we are parsing tables!
		while(1){
			while(this.stream.next() != "\n" && 
				this.stream.next()!= null){}
			//we're at the start of a table line
			//eat up all whitespace before start of commands
			//(this allows us to use indentation in tables)
			while(this.stream.next() != "|"&& 
				this.stream.next()!= null){}
			if(this.stream.peek()== "+"){
				//This is a caption.
				this.stream.next();
				c= this.parseUntil("\n");
				ret += "<caption>"+c+"<\/caption>";
			}else if(this.stream.peek()== " "){
				this.stream.next();
				c = this.parseTableData();
				if(firstRow){
					ret+="<tr>";
					firstRow = false;
				}
				ret+= c;
			}else if (this.stream.peek() == "-"){
				this.stream.next();
				//ensure that we have seen a row already
				if(firstRow == false){
					ret += "<\/tr><tr>";
				}
			}else if(this.stream.peek()=="}" 
				|| this.stream.peek()==null){
				this.stream.next();
				break
			} else{
				//default case is to parse as if it were data
				c = this.parseTableData();
				if(firstRow){
					ret+="<tr>";
					firstRow = false;
				}
				ret+= c;
			}
		}
		if(firstRow==false){
			ret += "</tr>";
		}
		ret += "</table>";
		//alert(ret);
		return ret;
	}
			
					
				
				
			

	this.parseSpecial = function(){
		var c;
		var ret = "";
		c = this.stream.next();
		switch (c){
			case null:
				this.stream.next();
				break;
			case "\n":
				//if(this.stream.peek()=="\n"){
					ret += "\n<br />\n";
			//	}
				break;
			case "!":
				ret+= this.parseHeader();
				break;
			case "+":
				ret += this.parseList("+","ul");
				break;
			case "#":
				ret += this.parseList("#","ol");
				break;
			// FIXME: have one typesetting function, with
			// a "endchar" and "tag" parameters
			case "*":
				ret += this.parseTypesetting("*","b");
				break;
			case "_":
				ret += this.parseTypesetting("_","u");
				break;
			case "/":
				ret += this.parseTypesetting("/","i");
				break;
			case "\\":
				ret += this.parseEscape();
				break;
			case "[":
				ret += this.parseLink();
				break;
			case "<":
				ret += this.parseXML();
				break;
			case "-":
				ret += this.parseHorizontalRule();
				break;
			case "{":
				ret += this.parseTable();
		}
		return ret;
	}

	this.parse = function(){
		while(this.stream.peek()!=null){
			this.result+=this.parseNormal();
			if(this.stream.peek()){
				this.result+=this.parseSpecial();
			}
		}
		//FIXME: this is a pretty big hack
		// clean up the output of parseBullet:
		for(i=0; i<4; i++)
		{
			this.result = this.result.replace(/\<\/ul\>\<ul\>/g, "");
			this.result = this.result.replace(/\<\/ul\>\n\<ul\>/g, "");
		}
		for(i=0; i<4; i++)
		{
			this.result = this.result.replace(/\<\/ol\>\<ol\>/g, "");
			this.result = this.result.replace(/\<\/ol\>\n\<ol\>/g, "");
		}
		return this.result;
	}
}

function parse(text){
	var parser = new HandWrittenParser(text);
	var data = parser.parse();
	//alert(data);
	return data;
}

function validateParsing(text){
	var parser = new HandWrittenParser(text);
	parser.validate=true;
	var data = parser.parse();
	//FIXME: Now we have validated that is parses correctly, 
	//We still need to validate the resulting XML
	return data;
}



// Gets text typed by user
function get_text(title)
{
	var pages = el("wiki").childNodes;
	for(i=0; i<pages.length; i++)
		if(pages[i].id)
			if(pages[i].id.toUpperCase() == title.toUpperCase())
				return unescape(pages[i].innerHTML);
	return "not found";
}

// Sets text typed by user
function set_text(text)
{
	var pages = el("wiki").childNodes;
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
			if(pages[i].id.toUpperCase() == current.toUpperCase())
				pages[i].innerHTML = escape(text);
	}
}

// Returns a index of all pages
function special_all_pages()
{
	var pages = el("wiki").childNodes;
	var pg = new Array();
	var text = "";
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
		{
			if(!pages[i].id.match("Special::"))
				pg.push("+ [[" + visible_name(pages[i].id) + "]]");
		}
	}
	return pg.sort().join("\n");
}

// Returns a index of all dead pages
function special_dead_pages()
{
	var pages = el("wiki").childNodes;
	var pg = new Array();
	var text = "";
	for(j=0; j<pages.length; j++)
	{
		if(pages[j].id)
		{
			text = unescape(pages[j].innerHTML);
			text.replace(/\[\[([^\]\]]*?)\|(.*?)\]\]/g, function(str, $1, $2)
					{
						if(!page_exists($2))
							if(!$2.match("://"))
								pg.push("+ [[" + $2 + "]]");
					});
			text.replace(/\[\[([^\|]*?)\]\]/g, function(str, $1)
					{
						if(!page_exists($1))
							if(!$1.match("://"))
								pg.push("+ [[" + $1 + "]]");
					});
		}
	}
	if(pg.length == 0)
		return "";
	else
		return pg.sort().join("\n"); // TODO - Delete repeated data
}

// Returns a index of all dead pages
function special_orphaned_pages()
{
	var pages = el("wiki").childNodes;
	var pg = new Array();
	for(j=0; j<pages.length; j++)
	{
		found = false;
		// search for pages that link to it
		for(i=0; i<pages.length; i++)
			if(pages[i].innerHTML)
				if(pages[j].id)
					if(pages[i].innerHTML.toUpperCase().match("%5B%5B" + pages[j].id.toUpperCase() + "%5D%5D")
							|| pages[i].innerHTML.toUpperCase().match("%7C" + pages[j].id.toUpperCase() + "%5D%5D"))
						found = true;
		if(pages[j].id)
			if(found == false)
				if(!pages[j].id.match("Special%3A%3A"))
					pg.push("+ [[" + unescape(pages[j].id) + "]]");
	}
	if(pg.length == 0)
		return "";
	else
		return pg.sort().join("\n"); // TODO - Delete repeated data
}

// Load a new current page
function set_current(cr)
{
	var text;
	
	if(cr.match("Special%3A%3A"))
	{
		switch(cr)
		{
			case "Special%3A%3AAdvanced":
				text = get_text(cr);
				break;
			case "Special%3A%3AAll%20Pages":
				text = special_all_pages();
				break;
			case "Special%3A%3AOrphaned%20Pages":
				text = special_orphaned_pages();
				break;
			case "Special%3A%3APages%20not%20yet%20created":
				text = special_dead_pages();
				break;
			case "Special%3A%3ABlock%20Edits":
				if(get_var("permit_edits") == "1")
				{
					set_var("permit_edits", "0");
					document.getElementById("menu_edit").style.display = "none";
					document.getElementById("menu_edit_button").style.display = "none";
					if(unsupported_browser)
						document.getElementById("unsupported_browser").style.display = "none";
					alert("Edits blocked.");
				}
				else
				{
					set_var("permit_edits", "1");
					document.getElementById("menu_edit").style.display = "block";
					document.getElementById("menu_edit_button").style.display = "block";
					if(unsupported_browser)
						document.getElementById("unsupported_browser").style.display = "block";
					alert("Edits unblocked.");
				}
				if(debug == false)
					saveThisFile();
				home();
				return;
			case "Special%3A%3AEdit%20CSS":
				el("edit_page_title").style.display = "none";
				el("editor").value = document.getElementsByTagName("style")[0].innerHTML;
				adjust_menu(1);
				el("title").innerHTML = visible_name(cr);
				document.title = visible_name(cr);
				current = cr;
				return;
			case "Special%3A%3AEdit%20Menu":
				el("edit_page_title").style.display = "none";
				el("editor").value = get_text(cr);
				adjust_menu(1);
				el("title").innerHTML = visible_name(cr);
				document.title = visible_name(cr);
				current = cr;
				return;
			default:
				text = get_text(cr);
				current=cr;
				if(text == "not found")
					alert("Invalid special page.");
				else
				{
					el("wiki_text").innerHTML = parse(text);
					el("menu_area").innerHTML = parse(get_text("Special%3A%3AEdit%20Menu"));
					current = cr;
					el("title").innerHTML = visible_name(cr);
					document.title = visible_name(cr);
					adjust_menu(0);
				}
				return;
		}
	}
	else
		text = get_text(cr);
	if(text == "not found")
	{
		if(confirm("Page not found. Do you want to create it?"))
		{
			el("wiki").innerHTML = el("wiki").innerHTML + "<div id='" + cr + "'>Insert text here.<\/div>";
			text = "Insert text here.";
			if(debug == false)
				saveThisFile();
		}
		else
			return;
	}
	el("wiki_text").innerHTML = parse(text);
	el("menu_area").innerHTML = parse(get_text("Special%3A%3AEdit%20Menu"));



	current = cr;
	el("title").innerHTML = visible_name(cr);
	document.title = visible_name(cr);
	if(document.getElementById("lastDate"))
		document.getElementById("lastDate").innerHTML = document.lastModified;
	adjust_menu(0);
}

// when the page is loaded
function on_load()
{
	/* if((navigator.userAgent).indexOf("Opera")!=-1)
		opera = true;
	else */ if(navigator.appName == "Netscape")
		firefox = true;
	else if((navigator.appName).indexOf("Microsoft")!=-1)
		ie = true;

	// finds out if Opera is trying to look like Mozilla
	if(firefox == true && navigator.product != "Gecko")
		firefox = false;

	// finds out if Opera is trying to look like IE
	if(ie == true && navigator.userAgent.indexOf("Opera") != -1)
		ie = false;

	if(debug == true)
		el("debug_info").style.display = "block";
	if(get_var("permit_edits") == "0")
	{
		document.getElementById("menu_edit").style.display = "none";
		document.getElementById("menu_edit_button").style.display = "none";
		document.getElementById("unsupported_browser").style.display = "none";
	}
	else
	{
		document.getElementById("menu_edit").style.display = "block";
		document.getElementById("menu_edit_button").style.display = "block";
	}
	if(ie == true)
	{
		el("img_back").style.display = "none";
		el("img_forward").style.display = "none";
		el("img_home").style.display = "none";
		el("img_edit").style.display = "none";
		el("img_cancel").style.display = "none";
		el("img_save").style.display = "none";
		el("img_advanced").style.display = "none";
		el("alt_back").style.display = "block";
		el("alt_forward").style.display = "block";
		el("alt_home").style.display = "block";
		el("alt_edit").style.display = "block";
		el("alt_cancel").style.display = "block";
		el("alt_save").style.display = "block";
		el("alt_advanced").style.display = "block";
		el("alt_advanced").innerHTML = ":";
		el("alt_back").innerHTML = "&#223;";
		el("alt_forward").innerHTML = "&#224;";
		el("alt_home").innerHTML = "G";
		el("alt_edit").innerHTML = "&#33;";
		el("alt_cancel").innerHTML = "&#253;";
		el("alt_save").innerHTML = "&#60;";
	}
	else
	{
		el("img_back").style.display = "block";
		el("img_forward").style.display = "block";
		el("img_home").style.display = "block";
		el("img_edit").style.display = "block";
		el("img_cancel").style.display = "block";
		el("img_save").style.display = "block";
		el("img_advanced").style.display = "block";
		el("alt_back").style.display = "none";
		el("alt_forward").style.display = "none";
		el("alt_home").style.display = "none";
		el("alt_edit").style.display = "none";
		el("alt_cancel").style.display = "none";
		el("alt_save").style.display = "none";
		el("alt_advanced").style.display = "none";
	}

	// Go straight to page requested
	if(document.location.href.split("#")[1])
	{
		if(page_exists(document.location.href.split("#")[1]))
			current = escape(unescape(document.location.href.split("#")[1]));
		else
			current = get_var("main_page");
			}
	else
		current = get_var("main_page");

	set_current(current);

	if(firefox == true || ie == true)
	{
		unsupported_browser = false;
		document.getElementById("unsupported_browser").style.display = "none";
		}
}




// when the page is resized
function on_resize()
{
	if(ie == false)
	{
		el("editor").style.width = window.innerWidth - 30 + "px";
		el("editor").style.height = window.innerHeight - 150 + "px";
	}
}

// Adjusts the menu. 0 for viewing, 1 for editing
function adjust_menu(editing)
{
	switch(editing)
	{
		case 0:
			// check for back and forward buttons - TODO grey out icons
			if(backstack.length > 0)
				el("menu_back").style.display = "block";
			else
				el("menu_back").style.display = "none";
			if(forstack.length > 0)
				el("menu_forward").style.display = "block";
			else
				el("menu_forward").style.display = "none";
			if(current == "Special%3A%3AAdvanced")
				el("menu_advanced").style.display = "none";
			else
				el("menu_advanced").style.display = "block";
			el("menu_home").style.display = "block";
			if(current.match("Special%3A%3A") || get_var("permit_edits") == "0")
				el("menu_edit").style.display = "none";
			else
				el("menu_edit").style.display = "block";
			el("menu_save").style.display = "none";
			el("menu_cancel").style.display = "none";
			el("text_area").style.display = "block";
			el("edit_area").style.display = "none";
			break;
		case 1:
			el("menu_back").style.display = "none";
			el("menu_forward").style.display = "none";
			el("menu_advanced").style.display = "none";
			el("menu_home").style.display = "none";
			el("menu_edit").style.display = "none";
			el("menu_save").style.display = "block";
			el("menu_cancel").style.display = "block";
			el("text_area").style.display = "none";
			if(ie == false)
			{
				el("editor").style.width = window.innerWidth - 30 + "px";
				el("editor").style.height = window.innerHeight - 150 + "px";
			}
			el("edit_area").style.display = "block";
			break;
	}
}

// when edit is clicked
function edit()
{
	el("page_title").value = visible_name(current);
	el("editor").value = get_text(current);
	adjust_menu(1);
}

// renames a page
function rename_page(previous, newpage)
{
	if(previous == get_var("main_page"))
		set_var("main_page", newpage);
	var pages = el("wiki").childNodes;
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
		{
			if(pages[i].id == previous)
			{
				pages[i].id = newpage;
				// TODO - change all references
				return;
			}
		}
	}
}

// when a page is deleted
function delete_page(page)
{
	var wiki = document.getElementById("wiki");
	var pages = wiki.childNodes;
	for(i=0; i<pages.length; i++)
	{
		if(pages[i].id)
			if(pages[i].id.toUpperCase() == current.toUpperCase())
			{
				wiki.removeChild(pages[i]);
				return;
			}
	}
}

// when save is clicked
function save()
{
	switch(current)
	{
		case "Special%3A%3AEdit%20CSS":
			document.getElementsByTagName("style")[0].innerHTML = el("editor").value;
			set_current(get_var("main_page"));
			el("edit_page_title").style.display = "block";
			break;
		case "Special%3A%3AEdit%20Menu":
			el("menu_area").innerHTML = parse(el("editor").value);
			set_text(el("editor").value);
			set_current(get_var("main_page"));
			el("edit_page_title").style.display = "block";
			break;
		default:
			// check if text is empty
			if(el("editor").value == "")
			{
				if(confirm("Are you sure you want to DELETE this page?"))
				{
					delete_page(current);
					set_current(get_var("main_page")); // TODO - go to previous page
				} else
					return;
			}
			else
			{
				//JC - first ensure that new page parses:
				try{
					validateParsing(el("editor").value);
				}catch(e){
					if(confirm("An error was detected in the page\n"+
							"Would you like to move the cursor to\n"+
							"The problem and continue editing?")){
						el("editor").select();
						el("editor").selectionStart = e-1;
						el("editor").selectionEnd = e;
						el("editor").focus();
						return;
					}
				}
				//then save it
				set_text(el("editor").value);
				if(valid_name(el("page_title").value) != current)
					rename_page(current, valid_name(el("page_title").value));
				set_current(valid_name(el("page_title").value));
			}
	}
	adjust_menu(0);
	if(debug == false)
		saveThisFile();
}

// when cancel is clicked
function cancel()
{
	if(confirm("Are you sure you want to cancel this edit?"))
		adjust_menu(0);
	// TODO - when Editing CSS and canceling, title gets Edit CSS
}

// when home is clicked
function home()
{
	go_to(get_var("main_page"));
	if(get_var("permit_edits") == "0")
	{
		document.getElementById("menu_edit").style.display = "none";
		document.getElementById("menu_edit_button").style.display = "none";
	}
	else
	{
		document.getElementById("menu_edit").style.display = "block";
		document.getElementById("menu_edit_button").style.display = "block";
	}
}

// when Advanced is clicked
function advanced()
{
	go_to("Special%3A%3AAdvanced");
}

// follows a link
function go_to(cr)
{
	if(cr == current)
		return;
	backstack.push(current);
	forstack = new Array();
	set_current(cr);
}

// when Back button is clicked
function go_back()
{
	if(backstack.length > 0)
	{
		forstack.push(current);
		set_current(backstack.pop());
	}
}

// when Forward button is clicked
function go_forward()
{
	if(forstack.length > 0)
	{
		backstack.push(current);
		set_current(forstack.pop());
	}
}

// save this file
function saveThisFile()
{ 
	if(unsupported_browser)
	{
		alert("This browser is not supported and your changes won't be saved on disk.");
		return;
	}
	var filename = document.location.toString().split("#")[0];
	filename = filename.replace("file:///", "");
	filename = filename.replace(/%20/g, " ");
	if(navigator.appVersion.indexOf("Win")!=-1)
		filename = filename.replace(/\//g, "\\");
	else
		filename = "/" + filename;
	saveFile(filename, "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">" + document.documentElement.innerHTML + "<\/html>");
}

// Copied from TiddyWiki
function saveFile(fileUrl, content)
{
	var r = null;
	r = mozillaSaveFile(fileUrl, content);
	if((r == null) || (r == false))
		r = ieSaveFile(fileUrl, content);
	if((r == null) || (r == false))
		r = operaSaveFile(fileUrl, content);
	return(r);
}

function loadFile(filePath)
{
	var r = null;
	r = mozillaLoadFile(filePath);
	if((r == null) || (r == false))
		r = ieLoadFile(filePath);
	if((r == null) || (r == false))
		r = operaLoadFile(filePath);
	return(r);
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function ieSaveFile(filePath, content)
{
	try
	{
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	}
	catch(e)
	{
		//alert("Exception while attempting to save\n\n" + e.toString());
		return(null);
	}
	var file = fso.OpenTextFile(filePath,2,-1,0);
	file.Write(content);
	file.Close();
	return(true);
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function ieLoadFile(filePath)
{
	try
	{
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var file = fso.OpenTextFile(filePath,1);
		var content = file.ReadAll();
		file.Close();
	}
	catch(e)
	{
		//alert("Exception while attempting to load\n\n" + e.toString());
		return(null);
	}
	return(content);
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function mozillaLoadFile(filePath)
{
	if(window.Components)
		try
		{
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if (!file.exists())
				return(null);
			var inputStream = Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream);
			inputStream.init(file, 0x01, 00004, null);
			var sInputStream = Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream);
			sInputStream.init(inputStream);
			return(sInputStream.read(sInputStream.available()));
		}
		catch(e)
		{
			//alert("Exception while attempting to load\n\n" + e);
			return(false);
		}
	return(null);
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function mozillaSaveFile(filePath, content)
{
	if(window.Components)
		try
		{
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if (!file.exists())
				file.create(0, 0664);
			var out = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
			out.init(file, 0x20 | 0x02, 00004,null);
			out.write(content, content.length);
			out.flush();
			out.close();
			return(true);
		}
		catch(e)
		{
			alert("Exception while attempting to save\n\n" + e);
			return(false);
		}
	return(null);
}

function operaUrlToFilename(url)
{
	var f = "//localhost";
	if(url.indexOf(f) == 0)
		return url.substring(f.length);
	var i = url.indexOf(":");
	if(i > 0)
		return url.substring(i-1);
	return url;
}

function operaLoadFile(filePath)
{
	var content = [];
	try
	{
		var r = new java.io.BufferedReader(new java.io.FileReader(operaUrlToFilename(filePath)));
		var line;
		while ((line = r.readLine()) != null)
			content.push(new String(line));
		r.close();
	}
	catch(e)
	{
		if(window.opera)
			opera.postError(e);
		return null;
	}
	return content.join("\n");
}

function operaSaveFile(filePath, content)
{
	try
	{
		var s = new java.io.PrintStream(new java.io.FileOutputStream(operaUrlToFilename(filePath)));
		s.print(content);
		s.close();
	}
	catch(e)
	{
		if(window.opera)
			opera.postError(e);
		return null;
	}
	return true;
}

function import_wiki()
{
	var filename = el("filename_").value;
	if(filename == "")
	{
		alert("A file must be selected");
		return false;
	}

	if(confirm("This will DELETE ALL YOUR DATA and replace with the new imported data. Are you sure you want to do this?") == false)
		return;

	document.body.style.cursor= "wait";
	
	var ct = loadFile(filename);
	
	// get version
	var version;
	try {
		switch(ct.match(/\<div id=\"version_\"\>(.*)\<\/div\>/i)[1])
		{
			case "0.03":
				version = 3;
				break;
			case "0.04": 
				version = 4;
				break;
			default:
				alert("Incompatible version");
				return false;
		}
	} catch(e) {
		version = 2;
		if(ct.match("<div id=\"Special%3A%3AAdvanced\">"))
			version = 3;
	}

	// get only the needed part
	var wiki;
	try {
		wiki = ct.match(/\<div .*id=\"wiki\"\>((.|\n|\t|\s)*)\<\/div\>/)[0];
	} catch(e) {
		alert("Unrecognized file");
		return false;
	}
	
	// eliminate comments
	wiki = wiki.replace(/\<\!\-\-.*\-\-\>/g, "");

	// separate variables from wiki
	var vars;
	try {
		vars = wiki.match(/\<div .*id=\"variables\"\>((.|\n|\t|\s)*)\<\/div\>/)[0];
	} catch(e) {
		vars = "";
	}
	if(version == 2)
	{
		try {
			vars = wiki.match(/\<div.*id=\"main_page\".*\>(.*)\<\/div\>/)[0];
		} catch(e) {
		}
	}
	wiki = wiki.replace(vars, "");

	// get an array of variables and wikis
	var var_names = new Array();
	var var_values = new Array();
	var vc = 0;
	var page_names = new Array();
	var page_contents = new Array();
	var pc = 0;

	// eliminate headers
	wiki = wiki.replace(/\<div.*?id=\"wiki\".*?\>/, "");
	vars = vars.replace(/\<div.*?id=\"variables\".*?\>/, "");

	vars.replace(/\<div.*?id=\"(.*?)\".*?\>((\n|.)*?)\<\/div\>/g, function(str, $1, $2)
			{
				if(version == 2)
				{
					var_names[vc] = "main_page_";
					var_values[vc] = valid_name($2);
				}
				else
				{
					var_names[vc] = $1;
					var_values[vc] = $2;
				}
				vc++;
			});
	wiki.replace(/\<div.*?id=\"(.*?)\".*?\>((\n|.)*?)\<\/div\>/g, function(str, $1, $2, $3)
			{
				if(version == 2)
					page_names[pc] = valid_name($1);
				else
					page_names[pc] = $1;
				page_contents[pc] = $2;
				pc++;
			});

	// delete all data
	var elem = el("wiki").childNodes;
	for(i=0; i<elem.length; i++)
	{
		if(elem[i].id)
			if(elem[i].id.search("Special%3A%3A") != 0 || elem[i].id == "Special%3A%3AEdit%20Menu")
				el("wiki").removeChild(elem[i]);
	}
	elem = el("variables").childNodes;
	for(i=0; i<elem.length; i++)
	{
		if(elem[i].id)
			if(elem[i].id.toUpperCase() != "VERSION_")
				el("variables").removeChild(elem[i]);
	}

	// add new data
	var pages_imported = 0;
	for(i=0; i<var_names.length; i++)
		if(var_names[i].toUpperCase() != "VERSION_")
			el("variables").innerHTML += "<div id=\"" + var_names[i] + "\">" + var_values[i] + "<\/div>";
	el("variables").innerHTML += "<div id=\"version_\">0.04<\/div>";
	if(version < 4)
		el("variables").innerHTML += "<div id=\"permit_edits_\">1<\/div>";
	for(i=0; i<page_names.length; i++)
	{
		if(page_names[i].search("Special%3A%3A") != 0)
		{
			if(version == 2)
				el("wiki").innerHTML += "<div id=\"" + page_names[i] + "\">" + escape(page_contents[i]) + "<\/div>";
			else
				el("wiki").innerHTML += "<div id=\"" + page_names[i] + "\">" + page_contents[i] + "<\/div>";
			pages_imported++;
		}
		if(page_names[i] == "Special%3A%3AEdit%20Menu")
		{
			if(version == 2)
				el("wiki").innerHTML += "<div id=\"" + page_names[i] + "\">" + escape(page_contents[i]) + "<\/div>";
			else
				el("wiki").innerHTML += "<div id=\"" + page_names[i] + "\">" + page_contents[i] + "<\/div>";
			pages_imported++;
		}
	}

	document.body.style.cursor= "auto";

	alert("Import completed: " + pages_imported + " pages imported.");
	if(debug == false)
		saveThisFile();

	home();

}

function open_table_help()
{
	w = window.open("about:blank", "help", "height=200px, width=350px, menubar=no, toolbar=no, location=no, status=no, dialog=yes");
	w.document.writeln("<html><head><title>Building tables<\/title><\/head><body>");
	w.document.writeln("<u>Building tables:<\/u><br><br>");
	w.document.writeln("<tt>{|   <\/tt><br>");
	w.document.writeln("<tt>|+ Table Caption<\/tt><br>");
	w.document.writeln("<tt>| *colum 1* || *column 2* || *column 3*<\/tt><br>");
	w.document.writeln("<tt>|-<\/tt><br>");
	w.document.writeln("<tt>| line 2 || [[a link]] || something<\/tt><br>");
	w.document.writeln("<tt>|-<\/tt><br>");
	w.document.writeln("<tt>| line 3 || || more stuff<\/tt><br>");
	w.document.writeln("<tt>|}   <\/tt>");
	w.document.writeln("<\/body><\/html>");
	w.document.close();
}

window.onresize = on_resize;

]]>
</script>
<!-- End of Javascript code -->









     <title>
       XMLwiki DEVELOPMENT VERSION
     </title>
   </head>




   <body id="body" onload="on_load()">
	   

	   <iframe style="display: none;" id="nav_iFrame" />
	<!-- Title & menu -->

<table cellspacing="0">
		<tbody><tr>
			<td style="width: 100%;" valign="bottom">
				<p class="title" id="title">Main Page</p>
			</td>
			<td class="menu" onclick="go_back()"><div style="display: none; cursor: pointer;" id="menu_back"><img style="display: block;" id="img_back" alt="Back" src="StickWiki_files/a_002" /><span id="alt_back" style="display: none; font-family: wingdings; font-size: 24pt;">ß</span></div></td>


			<td class="menu" onclick="go_forward()"><div style="display: none; cursor: pointer;" id="menu_forward"><img style="display: block;" id="img_forward" alt="Forward" src="StickWiki_files/a_005" /><span id="alt_forward" style="display: none; font-family: wingdings; font-size: 24pt;">à</span></div></td>


			<td class="menu" onclick="advanced()"><div style="display: block; cursor: pointer;" id="menu_advanced"><img style="display: block;" id="img_advanced" alt="Advanced" src="StickWiki_files/a_006" /><span id="alt_advanced" style="display: none; font-family: wingdings; font-size: 24pt;">:</span></div></td>


			<td class="menu" onclick="home()"><div style="display: block; cursor: pointer;" id="menu_home"><img style="display: block;" id="img_home" alt="Home" src="StickWiki_files/a_003" /><span id="alt_home" style="display: none; font-family: wingdings; font-size: 24pt;">G</span></div></td>


			<td class="menu" onclick="edit()"><div style="display: block; cursor: pointer;" id="menu_edit"><img style="display: block;" id="img_edit" alt="Edit" src="StickWiki_files/a_004" /><span id="alt_edit" style="display: none; font-family: wingdings; font-size: 24pt;">!</span></div></td>


			<td class="menu" onclick="cancel()"><div id="menu_cancel" style="display: none; cursor: pointer;"><img style="display: block;" id="img_cancel" alt="Cancel" src="StickWiki_files/a" /><span id="alt_cancel" style="display: none; font-family: wingdings; font-size: 24pt;">ý</span></div></td>
			
			
			<td class="menu" onclick="save()"><div id="menu_save" style="display: none; cursor: pointer;"><img style="display: block;" id="img_save" alt="Save" src="StickWiki_files/a_007" /><span id="alt_save" style="display: none; font-family: wingdings; font-size: 24pt;">&lt;</span></div></td>
		</tr>
	</tbody></table>

	<hr />
	<!-- End of title and menu -->


	<!-- Text to be shown -->
	<div style="display: none;" id="debug_info">
		<i>If you see this text, you're using a development version. It won't save on disk until you find the line that says </i>
		<b><tt>var debug = true;</tt></b>
		<i> and change it to </i>
		<b><tt>false</tt></b>.
	</div>
	<div style="display: none;" id="unsupported_browser">
		<i>Your browser is not supported. You can access the wiki but you won't be able to save. Sorry.</i>
	</div>

	<!-- Left Navigation Menu -->
	<table style="display: block;" id="text_area" cellspacing="10"><tbody><tr>
		<td valign="top">
			<div class="menu_area">
				<div class="wiki" id="menu_area">
					<p><a class="link" onclick='go_to("Main%20Page")'>Main Page</a></p>
				</div>
				<span style="display: block;" id="menu_edit_button">
					<hr />
					<div style="text-align: center;">
						<a class="link" onclick='go_to("Special%3A%3AEdit%20Menu")'>
							[Edit]
						</a>
					</div>
				</span>
			</div>
		</td>
	<!-- End of left Navigation menu -->
	<!-- Main window -->
		<td style="width: 88%;" rowspan="2" valign="top">
			<div class="text_area" id="wiki_text">
				<p>Insert text here. (alternatively, you can 
				<a class="link" onclick='go_to("Special%3A%3AImport%20wiki")'>
					import from a ealier version
				</a>)
				</p>
			</div>
		</td>
	<!-- End of main window -->
	</tr>
	<tr>
		<td>&nbsp;</td>
	</tr></tbody></table>




	<!-- Editor -->
	<div style="display: none;" id="edit_area">
		<div style="display: block;" id="edit_page_title">
			Page title: <input id="page_title" type="text" />
		</div>
		<textarea style="width: 714px; height: 245px;" cols="0" rows="0" id="editor"></textarea>
		<table style="font-size: 8pt;">
			<tbody><tr>
				<td>[[link]]</td>
				<td>[[http://link.com]]</td>
				<td>*bold*</td>
				<td>+ list</td>
				<td>!header</td>
				<td>--- (ruler)</td>
				<!-- JC - help note for math mode -->
				<td>$math mode$</td>
			</tr>
			<tr>
				<td>[[text|link]]</td>
				<td>_underline_</td>
				<td>/italic/</td>
				<td># numbered list</td>
				<td>!!subheader</td>
				<td><a class="world" onclick="open_table_help()">(tables)</a></td>
			</tr>
		</tbody></table>
	</div>



	<div style="display: none;" id="wiki">	
		
<!-- SPECIAL -->

		<div id="Special%3A%3AEdit%20Menu">%5B%5BMain%20Page%5D%5D</div>
		<div id="Special%3A%3AAdvanced">%21Queries%20%0A+%20%5B%5BAll%20Pages%7CSpecial%3A%3AAll%20Pages%5D%5D%3A%20a%20list%20of%20all%20pages%20in%20this%20wiki.%20%0A+%20%5B%5BPages%20not%20yet%20created%7CSpecial%3A%3APages%20not%20yet%20created%5D%5D%3A%20a%20list%20of%20pages%20that%20have%20links%20to%20them%2C%20but%20were%20still%20not%20created.%20%0A+%20%5B%5BOrphaned%20Pages%7CSpecial%3A%3AOrphaned%20Pages%5D%5D%3A%20a%20list%20of%20pages%20that%20once%20were%20linked%20to%2C%20but%20now%20no%20page%20links%20to%20them%20anymore.%0A%0A%21Visual%20%0A+%20%5B%5BEdit%20CSS%7CSpecial%3A%3AEdit%20CSS%5D%5D%20%0A+%20%5B%5BBlock/Unblock%20edits%7CSpecial%3A%3ABlock%20Edits%5D%5D%3A%20hides%20the%20edit%20button%2C%20to%20be%20used%20when%20this%20wiki%20goes%20public%20%28when%20used%20as%20a%20webpage%2C%20for%20example%29%0A%0A%21Import%20%0A+%20%5B%5BImport%20wiki%7CSpecial%3A%3AImport%20wiki%5D%5D%20from%20an%20early%20%28or%20current%29%20version.%0A%0A%21Info%0A+%20This%20wiki%20was%20last%20modified%20in%20%3Cspan%20id%3D%22lastDate%22%3E%5Berror%5D%3C/span%3E.</div>
		<div id="Special%3A%3AImport%20wiki">Import%20a%20wiki%20from%20an%20early%20%28or%20current%29%20version%3A%0A%0AFile%3A%20%3Cinput%20id%3D%22filename_%22%20type%3D%22file%22%20/%3E%3Cinput%20type%3D%22button%22%20value%3D%22Import%22%20onclick%3D%22import_wiki%28%29%22%20/%3E%0A%0A*Important%3A*%20CSS%20will%20%3Cu%3Enot%3C/u%3E%20be%20imported%2C%20as%20it%20might%20break%20some%20funcionality%20of%20the%20current%20version.</div>

<!-- WIKI -->

		<div id="Main%20Page">Insert%20text%20here.%20%28alternatively%2C%20you%20can%20%5B%5Bimport%20from%20a%20ealier%20version%7CSpecial%3A%3AImport%20wiki%5D%5D%29</div>

	</div>


<!-- VARIABLES -->
	<div style="display: none;" id="variables">
		<div id="main_page_">Main%20Page</div>
		<div id="version_">0.04</div>
		<div id="permit_edits_">1</div>
	</div>


   </body>
 </html>

