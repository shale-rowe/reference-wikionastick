<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
	<head>

<title>stickwiki - plumlocos version</title>

<!-- vim:sw=4:ts=4:sts=4:et:nu:
 --><!--
Icons taked from:
http://jimmac.musichall.cz/i.php?i=gorilla-stock

Saving/loading routines taken from:
http://www.tiddlywiki.com/

License:

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the Osmosoft Limited nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

-->


<meta name="author" content="andre">
<meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8"><!-- JAVASCRIPT -->  

<script type="text/javascript">

/////////////////////////////
// stickwiki.js
// vim:sw=4:ts=4:sts=4:et:nu:
//
// last modified at 09:13 on March 20, 2007 by plumloco@hcoop.net

//  GLOBALS

var debug = false;                  // won't save if it's true
var editing = false;                // true => allow editing, true => viewing only
var current = 'Special::Main Page'; // title of currently loaded page
var backstack = [];     // back button stack
var forstack = [];      // forward button stack
var all_pages = null;
var dead_links = null; 
var books = {};
var page_style = null;

// Browser 
var ie = false;
var firefox = false;
var opera = false;
var unsupported_browser = true;  

// HTML Interface

function el(e)
{
    if(typeof(e)=='string')
    {
        return document.getElementById(e);
    }
   return e;    
}

function def(x)
{
    return !(typeof(x)=='undefined');
}

function eDisplay(e, show)
{
    e = el(e);
    if (e && def(e.style) && def(e.style.display))
    {
        e.style.display = show?'block':'none';
        return e;
    }
    return null;
}


function getHTML(e)
{
    e = el(e);
    if (e && def(e.innerHTML))
    {
        return e.innerHTML;
    }
    return null;
}


function setHTML(e, html)
{
    e = el(e);
    if (e && def(e.innerHTML))
    {
        e.innerHTML = html;
        return e;
    }
    return null;
}


function getValue(e)
{
    e = el(e);
    if (e && def(e.value))
    {
        return e.value;
    }
    return null;
}


function setValue(e, value)
{
    e = el(e);
    if (e && def(e.value))
    {
        e.value = value;
        return e;
    }
    return null;
}

// utility functions

function foreach(a, fn)
{
    for (var i=0; i<a.length; i++)
    {
         fn( a[i], i);
    }
}


function encode(txt)
{
    return escape(txt);
}


function decode(txt)
{
    return unescape(txt);
}


function isSpecial(link)
{
    link = ulink(link||current)
    return (/(^|::)Special::/i.test(link)) && !isAdvanced(link);
}

function isAdvanced(link)
{
    return samepage( link||current, "Special::Advanced")
}

function isExternal(str)
{
    return (/:\/\//.test(str));
}


function iter_pages(book, fn)
{
    var page_list = books[book];

    for (var page in page_list)
    {
        fn(page_list[page]);
    }
}

function iter_all_pages(fn)
{
    for (var book in books)
    {
        iter_pages(book, fn);
    }
}


// CONSTRUCTOR for Page objects.
function Page(title, body, book)
{
    this.title = title;
    this.body = body;
    this.book = book || 'wiki';
}


// On Load Helpers.

function get_books()
{
    books['wiki'] = {};
    books.variables = {};
    for (var book in books)
    {
        get_page_list(book);
    }
}

function get_page_list(book)
{
    var pages, page_list, title, body, idx, x;
        
    page_list = books[book];

    //alert('get_page_list:' + book)
    pages = el(book).childNodes;
    
    for(var i=0; i<pages.length; i++)
    {
        if(pages[i].id)
        {
            title = decode(pages[i].id);
            body =decode(getHTML(pages[i]));
            idx = title.toUpperCase();

            if (page_list[idx])
            {
                x = 1;
                while (page_list[idx + ' :' + x])
                {   
                    x+=1;
                }
                title += ' :' + x;
                idx += ' :' + x;
                pages[i].id = encode(title);
            }
            page_list[idx] = new Page(title, body, book);
        }
    }
}


// Returns true if a page exists. 
//  Special pages always exist.
function page_exists(title)
{
    if (isSpecial(title))
    {
        return true;
    }
    var page_list = books.wiki;
    
    if (page_list[title.toUpperCase()])
    {
        return true;
    }
    return false;
}


// Returns the value of a wiki variable (wiki variable names end with a '_')
function get_var(name)
{
    return get_text(name + '_', 'variables');
}


// Sets the value of a wiki variable
function set_var(name, value)
{
    set_page(new Page(name + '_', value, 'variables'));
}


function get_text(title, book)
{
    var page = get_page(title, book);
    if (page)
    {
        return page.body;
    }
    else
    {
        return null;
    }
}


function special_export_single_webpage(testing)
{
    return saveWebPage(testing);
}


// Returns an index of all pages
function special_all_pages()
{
    var title, p, pg = [], pgs = [];
    iter_pages(
        'wiki',
        function(xpage)    
        {
            title = xpage.title;
            p = isSpecial(title)?pgs:pg;
            p.push("++ [[" + title + "]]");
        }
    );
   
    p = '+ Special Pages\n'
    + pgs.sort().join("\n")
    + '\n+ Wiki Pages\n'
    + pg.sort().join("\n");
    return p + '\n';
}

function ulink(link)
{
    if (link)
    {
        return  ((typeof(link) === 'string') ? link : link.title).toUpperCase();
    }
    else
    {
        alert('Bad link in ulink ', + link)
        return link;
    }
}


// CONSTRUCTOR for SetOfLinks OBJECT.
//  This object manages a Set of links. 
//   Two links are identical if the upper cased versions of each are identical.
//    Adding a link identical to one already in the set increments a counter for that link.
//
function SetOfLinks(){

    var links_ = {};
    var that = this;


    this.add = function(link)
    {
        link = ulink(link);

        if (link in links_)
        {
            links_[link] += 1;
        }
        else
        {
            links_[link] = 1;
        }
        return that
    };

    this.remove = function(link)
    {
        link = ulink(link);
        if (link in links_)
        {
            delete links_[link]
        }
        return that;
    }

    this.links = function(sorted)
    {   
        var links = [];
        for (var link in links_)
        {
            links.push(link);
        }
        return (sorted?links.sort():links);
    };

    
    this.toString = function (sorted)
    {
        var s = '';
        foreach
        (
            this.links(sorted),
            function (v)
            {
                s += '[[' + v + ']] (' + links_[v] + ')\n';
            }
        );    
        return s;
    };

    this.contains = function (link)
    {
        link = ulink(link)
        return link in links_ && links_[link];
    };

    
    this.iter_pages = function(sorted, fn)
    {
        var pages = this.links(sorted);
        for (var i=0; i<pages.length; i++)
        {
            fn(get_page(pages[i]));
        }
        return that;
    }


    this.remove_specials = function(flag)
    {
        var pages = this.links(false);
        for (var i=0; i<pages.length; i++)
        {
            var link = pages[i];
            if (isSpecial(link) || (flag && isAdvanced(link)))
            {
                delete links_[link];
            }
        }
        return that;
    }
}

function reap_links(xpage)
{
    function do_link(str, p1)
    {
        var a = p1.split(/\|/);
        //alert('do link\n' + p1 + '\n' + a[0] + '\n' + a[1])
        var link = a[1] || a[0];
        var token = a[1] && a[0];
        //alert('link: ' + link + '\ntoken' + token)
        if ((!link) || isSpecial(link) || isExternal(link))
        {
            return str;
        }
        if (page_exists(link))
        {
            xpage.to.add(link);
        }
        else
        {
            dead_links.add(link);
            //alert('dead\n' + link + '\n' + token)
        }
        return str;
    }
    var text = xpage.body;
    var reLink = /\[\[([^\]]+)\]\]/gm;
    text.replace(reLink, do_link);
}

// get all links
function get_links()
{
    var xpage, page, book, page_list;

    dead_links = new SetOfLinks();
    all_pages = new SetOfLinks();

    for (book in books)
    {
        page_list = books[book];            
        for (page in page_list)
        {
            xpage = page_list[page];
            xpage.from = new SetOfLinks();
            xpage.to = new SetOfLinks();
            all_pages.add(page);
        }
    }
    for (book in books)
    {
        page_list = books[book];
        for (page in page_list)
        {
            xpage = page_list[page];
            reap_links(xpage);
            foreach
            (
                xpage.to.links(),
                function (link)
                {
                    get_page(link).from.add(xpage.title);
                }
            );
        }
    }
}

// Returns a index of all dead pages
function special_dead_pages()
{
    get_links();
    return dead_links.toString(true);
}

function not_for_special(link)
{
    if (isSpecial(link||current)){
        alert( '    Sorry!\nThis feature does not work for Special:: pages.');
        return true;
    }
    return false;
}

function special_back_links()
{
    if ( not_for_special())
    {
        return false;
    }
    get_links();
    var page = get_page(current);
    if (page!==null)
    {
        return get_page(current).from.toString(true);
    }
    return false;     
}

function set_of_reachables()
{
    get_links();

    var xpage;
    var list = new SetOfLinks();
    var stk = [
        get_page(get_var('Main_Page')),
        get_page('Special::Edit menu')
    ];

    // build list of links that can be reached from MainPage or SideMenu.
    while (stk.length)
    {
        xpage = stk.pop();
        list.add(xpage.title);
        foreach
        (
            xpage.to.links(),
            function(link)
            {
                if (!list.contains(link))
                {
                    stk.push(get_page(link));
                }
            }
        );         
    }
    return list;
}
  
// Returns an index of all orphaned pages.
// An orphaned page is a page that can not be reached from the MainPage or the side menu.



function special_orphaned_pages()
{

    var reachables = set_of_reachables();

    // all pages - reachables = orphans

    var orphans = [];
    iter_pages('wiki', function(xpage)
    {
        if (!reachables.contains(xpage))
        {
            orphans.push(xpage.title);
        }
    });
    return '[[' + orphans.join(']]\n[[') + ']]';
}

// Special edits
function edit_special(page, text)
{
    current = page;
    document.title = page;
    setHTML("title", page);
    adjust_menu(1);
    setValue('page_title', page);
    setValue('editor', text);
    el('editor').focus();
}


function get_page_style()
{
    return getHTML(page_style);

}
function set_page_style(css)
{
    return setHTML(page_style, css);
}


// Load a new current page
function set_current(cr)
{
    var text;
    if (cr && samepage(cr, 'Special::Main Page'))
    {
        cr = false;
    }
    cr = cr || get_var('main_page');

    if(isSpecial(cr))
    {
        switch(cr.slice(9).toLowerCase())
        {
            case "advanced":
                text = get_text(cr);
                break;

            case "all pages":
                text = special_all_pages();
                break;

            case "orphaned pages":
                text = special_orphaned_pages();
                break;

            case "pages not yet created":
                text = special_dead_pages();
                break;

            case "back links":
                text = special_back_links();
                if (text === false)
                {
                    go_to_best();
                    return;
                }
                break;


            case "block edits":
                if(permitEdits())
                {
                    set_var("permit_edits", "0");
                    eDisplay("menu_edit", false);
                    eDisplay("menu_edit_button", false);
                    eDisplay("unsupported_browser", false);
                    alert("Edits blocked.");
                }
                else
                {
                    set_var("permit_edits", "1");
                    eDisplay("menu_edit", true);
                    eDisplay("menu_edit_button", true);
                    if(unsupported_browser)
                    {
                        eDisplay("unsupported_browser", true);
                    }
                    alert("Edits unblocked.");
                }
                saveThisFile();
                go_to_best();
                return;

            case "edit css":
                return edit_special(cr, get_page_style());

            case "edit menu":
                return edit_special(cr, get_text(cr));

            case "export single webpage":
                text = special_export_single_webpage();
                return 
            case "show parsed text":
                if (not_for_special() === true)
                {
                    return;
                }
                return edit_special(cr, parse(get_text(current)));

            default:
                alert('Invalid Special "' + cr + '"');
                return;
        }
    }
    else
    {
        text = get_text(cr);
        if (text === null)
        {
            if(confirm("Page not found. Do you want to create it?"))
            {   
                text = "Insert text here.";
                set_page(new Page(cr, text, 'wiki'));
                saveThisFile();
            }
        }
    }
    setHTML("wiki_text", parse(text));
    setHTML("menu_area", parse(get_text("Special::Edit Menu")));

    current = cr;
    setHTML("title", cr);
    document.title = cr;
    
    setHTML("lastDate", document.lastModified);

    adjust_menu(0);
}

// when the page is loaded
function on_load(){

    var flag;
    
    firefox = navigator.appName == "Netscape";
    ie = !firefox && (navigator.appName).indexOf("Microsoft")!=-1;

    // finds out if Opera is trying to look like Mozilla
    if(firefox  && navigator.product != "Gecko")
    {
        firefox = false;
    }

    // finds out if Opera is trying to look like IE
    if(ie && navigator.userAgent.indexOf("Opera") != -1)
    {
        ie = false; 
    }

    page_style = document.getElementsByTagName("style")[0];

    setup_menu();
    get_books();
    
    eDisplay("debug_info", debug);

    flag = permitEdits();
    eDisplay("menu_edit", flag);
    eDisplay("menu_edit_button", flag);

    flag = flag && !(firefox || ie) ;

    unsupported_browser = flag;
    eDisplay("unsupported_browser", flag);

    var icons = ['back', 'forward', 'home', 'edit', 'cancel', 'save', 'advanced'];
    var icon_codes = ["&#223;", "&#224;", "G", "&#33;", "&#253;" ,"&#60;", ":"];

    foreach
    (
        icons,
        function (icon, idx)
        {
            eDisplay('img_' + icon, !ie);
            eDisplay('alt_' + icon, ie);
            setHTML('alt_' + icon, icon_codes[idx]);
        }
    );

    // Go straight to page requested
    var docref = document.location.href.split("#")[1];
    
    if(docref && page_exists(unescape(docref)))
    {
        set_current (unescape(docref));
    }
    else
    {
        set_current();
    }
}

// when the page is resized
function on_resize()
{
    if(ie)
    {
        var e = el('editor');
        if (e)
        {
            e.style.width = window.innerWidth - 30 + "px";
            e.style.height = window.innerHeight - 150 + "px";
        }
    }
}
window.onresize = on_resize;

// Adjusts the menu. 0 for viewing, 1 for editing


function permitEdits()
{
     return get_var("permit_edits") == "1"   
}

function adjust_menu(editing)
{
    switch(editing)
    {
       
        case 0:
            // check for back and forward buttons - TODO grey out icons
            eDisplay("menu_back", backstack.length); 
            eDisplay("menu_forward", forstack.length);

            eDisplay("menu_advanced", !isAdvanced());

            eDisplay("menu_home", true);
            eDisplay("menu_edit", permitEdits() && !isSpecial());
   
            eDisplay("menu_save", false);
            eDisplay("menu_cancel", false);
            eDisplay("text_area", true);
            eDisplay("edit_area", false);
            break;


        case 1:
            foreach
            (
                ['back', 'forward', 'advanced', 'home', 'edit'],
                function (item)
                {
                    eDisplay('menu_' + item, false);
                }
            );
            eDisplay("text_area", false);

            eDisplay("menu_save", !samepage(current, 'Special::show parsed text'));
            eDisplay("menu_cancel", true);
            if(!ie)
            {
                el("editor").style.width = window.innerWidth - 30 + "px";
                el("editor").style.height = window.innerHeight - 150 + "px";
            }
            eDisplay("edit_area", true);
            eDisplay("edit_page_title", !isSpecial());
            break;
    }
}

// when edit is clicked
function edit()
{
    adjust_menu(1);
    setValue("page_title", current);
    setValue("editor", get_text(current));
    el("editor").focus();
}


function set_page(xpage)
{
    var book = xpage.book ;

    if (xpage)
    {
        books[book][ulink(xpage)] = xpage;

        var e = locate_element(xpage. title, book);
        if (!e) {
            setHTML
            (
                book,
                getHTML(book) 
                + '<div id="' 
                + encode(xpage.title) 
                + '">&nbsp;</div>'
            );
            e = locate_element(xpage. title, book);
        }
        if (null === setHTML( e, encode(xpage.body)))
        {
            alert
            (
                'Error in set_page:\n'
                + 'can not set "' + decode(e.id) 
                + '" in book "' + book + '"'
            );
            return;
        }
    }
    else
    {
        alert('Set Page Error');
    }
}

function get_page(title, book)
{
    var page_list = books[book || 'wiki'];
    if (page_list)
    {
        return page_list[ulink(title)];
    }
}

function change_links(text, from, to)
{

    function do_link(str, p1)
    {
        var a, link, token;

        a = p1.split('|', 1);
        if (a.length == 1)
        {
            if (a[0].toUpperCase() == from)
            {
                return '[[' + to + ']]';
            }
            return str;
        }
        else
        {
            if (a[1].toUpperCase() == from)
            {
                return '[[' + a[0] + '|' + to + ']]';
            }
            return str;
        }    

    }
    var reLink = /\[\[([^\]]+)\]\]/gm;
    return text.replace(reLink, do_link);
}


function samepage(a, b)
{
    return ulink(a) === ulink(b);
}

// renames a page
function rename_page(previous, newpage)
{
    alert('rename\n' + previous + '\n' + newpage);

    var errmsg = false

    if (isSpecial(previous) || isSpecial(newpage))
    {
        errmsg = 'Can\'t rename from or to a Special:: page'
    }


    if (!samepage(previous, newpage) && page_exists(newpage))
    {
        errmsg =  newpage + '" already exist, you must rename it or delete it' + '\n'
            + 'before renaming this page.'
    }

    if (errmsg)
    {
        alert
        (
            'Can not rename "' 
            + previous + '" to "' + newpage + '"\n\n"'
            + errmsg
        );
        return;
    }

    previous = ulink(previous);

    if(samepage(previous, get_var("main_page")))
    {
        set_var("main_page", newpage);
    }

    var xpage = get_page(previous);
    
    if (!xpage) 
    {
        alert('No page named "' + previous +'"!');
        return;
    }

    get_links();
    var links = xpage.from.links();

    delete_page(previous);
    xpage.title = newpage;
    set_page(xpage);

    foreach
    (
        links,
        function(link)
        {
            var xp = get_page(link);
            xp.body = change_links(xp.body, previous, newpage);
            set_page(xp);
        }
    );    
}

function locate_element(title, book)
{
    var pages = el(book).childNodes;
    var id = encode(title).toUpperCase();
    for(var i=0; i<pages.length; i++)
    {
        if(pages[i].id)
        {
            if(pages[i].id.toUpperCase() == id)
            {
                return pages[i];
            }
        }
    }
    return null;
}

// when a page is deleted
function delete_page(title, book)
{
    book = book || 'wiki';
    var cr  = locate_element(title, book);
    
    delete books[book][title.toUpperCase()];

    if (cr)
    {
        el(book).removeChild(cr);
    }
}



// when save is clicked
function save()
{
    var editor = el("editor");
    var text = getValue(editor);

    var title = getValue("page_title");

    switch(current.toLowerCase())
    {
        case "special::edit css":
            set_page_style(text);
            go_to_best();
            break;

        case "special::edit menu":
            setHTML("menu_area", parse(text));
            set_page(new Page(current, text));
            go_to_best();
            break;

        default:
            // check if text is empty
            if (text === "")
            {
                if(confirm("Are you sure you want to DELETE this page?"))
                {
                    delete_page(current);
                    go_to_best();
                }
                else
                {
                    return;
                }
            }
            else
            {
                //JC - first ensure that new page parses:
                try{
                    validateParsing(text);
                }catch(e){
                    if(confirm("An error was detected in the page\n"+
                            "Would you like to move the cursor to\n"+
                            "The problem and continue editing?")){
                        
                        editor.select();
                        editor.selectionStart = e-1;
                        editor.selectionEnd = e;
                        editor.focus();
                        return;
                    }
                }
                //then save it
                set_page(new Page(current, text));
                if (title != current)
                {
                    rename_page(current, title);
                }
                set_current(title);
            }
    }
    adjust_menu(0);
    saveThisFile();
}
// when cancel is clicked
function cancel()
{
    if (samepage(current, 'Special::show parsed text'))
    {
        adjust_menu()
        go_to_best()
    }
    else
    {
        if(confirm("Are you sure you want to cancel this edit?"))
        {
            adjust_menu(0);
            go_to_best()
        }
    }
}

// when home is clicked
function home()
{
    go_to(get_var("main_page"));
    var flag = (permitEdits());
    eDisplay("menu_edit", flag);
    eDisplay("menu_edit_button", flag);
}

// when Advanced is clicked
function advanced()
{
    go_to("Special::Advanced");
}

function go_to_best()
{
    if (!go_back())
    {
        if (!go_forward())
        {
            set_current();
        }
    }
}


function go_to_encoded(cr)
{
    go_to(decode(cr))
}

// follows a link
function go_to(cr)
{
    if(cr && cr != current)
    {
        backstack.push(current);
        forstack  = [];
    }
    set_current(cr);
}



// when Back button is clicked
function go_back()
{
    if(backstack.length)
    {
        if (!isSpecial())
        {
            forstack.push(current);
        }

        set_current(backstack.pop());
        return true;
    }
    return false;
}

// when Forward button is clicked
function go_forward()
{
    if(forstack.length)
    {
        if (!isSpecial())
        {
            backstack.push(current);
        }
        set_current(forstack.pop());
        return true;
    }
    return false;
}

window.onload = on_load;


////////////////////////////
// stickwiki_parser.js
// vim:sw=4:ts=4:sts=4:et:nu:

// I was thinking of looking around for a parser generator to create a parser
// for wikitext, but I decided that the language is simple enough to write a
// parser by hand.  Just to avoid future confusion, I specified in the name.

//Basically, it works like this:
// you give it a block of text, and it creates a TextStream of the block.
// The parse method calls parseNormal, which just does not text transformations,
// and simply returns the text it was able to parse whenever it hits a special
// character.
// parse then calls parseSpecial to handle the special character
// parseSpecial calls the appropriate specialized parser, which are almost all
// functions that recurse on parseNormal and parseSpecial, allowing all kinds
// of nesting of parsers.
// parseXML does not allow nesting


/// The TextStream class takes a block of text, and
/// allows it to be accessed as a stream, using
/// next(), and peek()

function TextStream(text){
    this.text = text;
    this.loc = 0;
    this.next = function(){
        if(this.loc >= this.text.length){
            return null;
        }
        var c = this.text.charAt(this.loc);
        this.loc = this.loc+1;
        return c;
    };
    this.peek = function(){
        if(this.loc >= this.text.length){
            return null;
        }
        return this.text.charAt(this.loc);
    };
}


function HandWrittenParser(text){
    this.validate = false;
    this.stream = new TextStream(text);
    this.result = "";
    // a list of special sequences.  Parse normal
    // returns when it encounters any of them
    this.specials = ["*","_","/","\n","!","+","#","[","]", "<", ">","\\", "-", "{", "|"];
 
    this.isSpecial = function(c){
        for(var i=0;i<this.specials.length;i++){
            if(this.specials[i]==c){
                return true;
            }
        }
        return false;
    };

    this.addText = function(cl){
        this.result += cl;
    };

    // parseNormal scans the text, adding
    // all "normal" characters to the result
    // and returning whenever it get a special
    // character
    this.parseNormal = function(){
        var c;
        var ret = "";
        while( (c = this.stream.peek())!==null){
            
            if(this.isSpecial(c)){
                break;
            }
            ret+=this.stream.next();
        }
        return ret;
    };


    this.parseUntil= function(stopChars){
        var body = ""
        do{
            body += this.parseNormal();
            if(stopChars.match(this.stream.peek())!==null){
                break;
            }else if(this.stream.peek()!==null){
                // recurse onto a different special element
                body=body+this.parseSpecial();
            }else{
                break;
            }
        }while(this.stream.peek()!==null);
        return body;
    };

    //parse header: see how many header levels we have
    this.parseHeader = function(){
        var lvl = 2;
        var body = "";
        while(this.stream.peek() == "!"){
            lvl++;
            this.stream.next();
        }
        
        // now we know what kind of header we have
        // we want to continuously run parsenormal
        // until we get to a newline to end it

        do{
            body += this.parseNormal();
            // we don't want to eat up the newline, because
            // it may be needed to end other tags.
            // however, if we don't, it gets caught by
            // parseSpecial, and the page looks like ass
            if(this.stream.peek()=="\n"){
                this.stream.next();
                break;
            }else if(this.stream.peek()!==null){
                // recurse onto a different special element
                body=body+this.parseSpecial();
            }else{
                break;
            }
        }while(this.stream.peek()!==null);
        return "<h"+lvl+">"+body+"</h"+lvl+">";
    };

    //Parse a bullet list
    //FIXME: this produces "dirty" output, each list element is
    //it's own list, so they are separated by newlines in the rendered
    //output.
    this.parseList = function(endChar, tag){
        var lvl = 1;
        var body = ""
        var startTag = "<"+tag+"><li>";
        var endTag = "</li><\/"+tag+">";
        while(this.stream.peek() == endChar){
            lvl++;
            startTag = "<"+tag+">"+startTag;
            endTag = endTag +"<\/"+tag+">";
            this.stream.next();
        }
        do{
            body += this.parseNormal();
            // we don't want to eat up the newline, because
            // it may be needed to end other tags.
            // however, if we don't, it gets caught by
            // parseSpecial, and the page looks like ass
            if(this.stream.peek()=="\n"){
                this.stream.next();
                break;
            }else if(this.stream.peek()!==null){
                // recurse onto a different special element
                body=body+this.parseSpecial();
            }else{
                break;
            }
        }while(this.stream.peek()!==null);
        body = startTag+body+endTag;
        return body;
    };

    this.parseTypesetting = function(endChar, tag){
        var body="";
        var start = this.stream.loc;
        do{
            body += this.parseNormal();
            if(this.stream.peek() ==endChar){
                this.stream.next();
                break;
            }else if(this.stream.peek()===null){
                if(this.validate){
                    alert("Unmatched tag started at character "+start+
                        "\nExpected \""+endChar+"\"");
                    throw start;
                }
                break;
            }
            body += this.parseSpecial();
        }while(1);
        var ret = "<"+tag+">"+body+"<\/"+tag+">";
        return ret;
    };

    this.parseEscape = function(){
        var c = this.stream.next();
        if(c!==null){
            return "&#"+c.charCodeAt(0)+";";
        }else{
            return "";
        }
    };

    this.parseLink = function(){
        var text = "";
        var target = "";
        var texting = true;     
        
        //ensure that we started with two brackets:
        if((text=this.stream.next())!="["){
            return "["+text;
        }
        text="";
        
        //in this case, we don't want to recurse.  All text
        // within the link should be taken literally.

        while(1){
            var c = this.stream.next();
            if(c=="|"){
                c="";
                texting = false;
            }else if(c=="]"){
                if(this.stream.peek() == "]"){
                    this.stream.next();
                    break;
                }
            }else if(c=="\""){
                c=this.parseEscape();
            }
            if(texting){
                text+=c;
            }else{
                target+=c;
            }
        }

        if(texting){

            if(text.match("://")){
                text= "<a class=\"world\" href=\"" + text 
                    + "\" target=\"_blank\">" + text + "<\/a>";
            }
            else if(page_exists(text)){
                text = '<a class="link" onclick="go_to_encoded(\'' 

                    + encode(text) +'\')">' + text + "<\/a>";
            }else{
                text ='<a class="unlink" onclick="go_to_encoded(\'' 

                    + encode(text) +'\')">' + text + "<\/a>";
            }
        }else{
            if(target.match("://")){
                text= "<a class=\"world\" href=\"" + target 
                    + "\" target=\"_blank\">" + text + "<\/a>";
            }
            else if(page_exists(target)){
                text = '<a class="link" onclick="go_to_encoded(\'' 
                    + encode(target) +'\')">' + text + "<\/a>";
            }else{
                text ='<a class="unlink" onclick="go_to_encoded(\'' 
                    + encode(target) +'\')">' + text + "<\/a>";
            }
        }
        return text;
    };    

    this.parseXML = function(){
        text ="<";
        var c;
        do{
            c = this.stream.next();
            if(c===null){
                break;
            }
            text += c;
        }while(c!=">");
        return text;
    };
        
    this.parseHorizontalRule = function(){
        var text = "-";
        var c = this.stream.next();
        text +=c;
        if(c!="-"){
            return text;
        }
        c = this.stream.next();
        text +=c;
        if(c!="-"){
            return text;
        }
        return "<hr \/>";
    };

    this.parseTableData = function(){
        var ret = "";
        var data = ""; 

        while(this.stream.peek() !="\n"){
            data += this.parseNormal();
            if(this.stream.peek() === null 
                    || this.stream.peek()=="\n"){
                if(data!=""){
                    ret+= "<td>"+data+"<\/td>";
                }
                data = "";
                break;
            }
            if(this.stream.peek() == "|"){
                this.stream.next();
                //not a double bar:
                // accept the input and keep going
                if(this.stream.peek() != "|"){
                    data+="|";
                    continue;
                }
                this.stream.next();
                ret+= "<td>"+data+"<\/td>";
                data ="";
            }else{
                data += this.parseSpecial();
            }
        }
        if(data !== ""){
            ret+= "<td>"+data+"<\/td>";
        }
        return ret;
    };

    this.parseTable = function(){
        var ret = "{"+this.stream.next();
        if(ret!= "{|"){
            return ret;
        }
        ret = "<table class=\"text_area\" ";
        var c;
        var firstRow = true;
        var attr="";
        // entire line following table opening
        // is xml code for table attributes, do not parse
        do{
            c = this.stream.peek();
            if(c===null){
                break;
            }
            if(c==="\n"){
                break;
            }
            attr += this.stream.next();
        }while(c!="\n");
        ret += attr+">";
        //Now we are parsing tables!
        while(1){
            while(this.stream.next() != "\n" && 
                this.stream.next()!== null){}
            //we're at the start of a table line
            //eat up all whitespace before start of commands
            //(this allows us to use indentation in tables)
            while(this.stream.next() != "|"&& 
                this.stream.next()!== null){}
            if(this.stream.peek() === "+"){
                //This is a caption.
                this.stream.next();
                c = this.parseUntil("\n");
                ret += "<caption>"+c+"<\/caption>";
            }else if(this.stream.peek()== " "){
                this.stream.next();
                c = this.parseTableData();
                if(firstRow){
                    ret+="<tr>";
                    firstRow = false;
                }
                ret+= c;
            }else if (this.stream.peek() == "-"){
                this.stream.next();
                //ensure that we have seen a row already
                if(firstRow === false){
                    ret += "<\/tr><tr>";
                }
            }else if(this.stream.peek()=="}" 
                || this.stream.peek()===null){
                this.stream.next();
                break;
            } else{
                //default case is to parse as if it were data
                c = this.parseTableData();
                if(firstRow){
                    ret+="<tr>";
                    firstRow = false;
                }
                ret+= c;
            }
        }
        if(firstRow===false){
            ret += "</tr>";
        }
        ret += "</table>";
        //alert(ret);
        return ret;
    };
            
    this.parseSpecial = function(){
        var c;
        var ret = "";
        c = this.stream.next();
        switch (c){
            case null:
                this.stream.next();
                break;
            case "\n":
                //if(this.stream.peek()=="\n"){
                    ret += "\n<br />\n";
            //  }
                break;
            case "!":
                ret+= this.parseHeader();
                break;
            case "+":
                ret += this.parseList("+","ul");
                break;
            case "#":
                ret += this.parseList("#","ol");
                break;
            // FIXME: have one typesetting function, with
            // a "endchar" and "tag" parameters
            case "*":
                ret += this.parseTypesetting("*","b");
                break;
            case "_":
                ret += this.parseTypesetting("_","u");
                break;
            case "/":
                ret += this.parseTypesetting("/","i");
                break;
            case "\\":
                ret += this.parseEscape();
                break;
            case "[":
                ret += this.parseLink();
                break;
            case "<":
                ret += this.parseXML();
                break;
            case "-":
                ret += this.parseHorizontalRule();
                break;
            case "{":
                ret += this.parseTable();
        }
        return ret;
    };

    this.parse = function(){

	var i;

        while(this.stream.peek()!==null){
            this.result+=this.parseNormal();
            if(this.stream.peek()){
                this.result+=this.parseSpecial();
            }
        }
        //FIXME: this is a pretty big hack
        // clean up the output of parseBullet:
        for(i=0; i<4; i++)
        {
            this.result = this.result.replace(/\<\/ul\>\<ul\>/g, "");
            this.result = this.result.replace(/\<\/ul\>\n\<ul\>/g, "");
        }
        for(i=0; i<4; i++)
        {
            this.result = this.result.replace(/\<\/ol\>\<ol\>/g, "");
            this.result = this.result.replace(/\<\/ol\>\n\<ol\>/g, "");
        }

        this.result = this.result.replace(/l\>/g, 'l>\n')
        return this.result;
    };
}

function parse(text){
    var parser = new HandWrittenParser(text);
    var data = parser.parse();
    //alert(data);
    return data;
}

function validateParsing(text){
    var parser = new HandWrittenParser(text);
    parser.validate=true;
    var data = parser.parse();
    //FIXME: Now we have validated that is parses correctly, 
    //We still need to validate the resulting XML
    return data;
}






/////////////////////////////
// stickwiki_display.js
// vim:sw=4:ts=4:sts=4:et:nu:
// code to create a single webpage of the wiki


function create_single_webpage()
{
    get_links();
 
    var reLink = /<a class="(?:un)?link" onclick="go_to_encoded\('([^']*)'\)">/g;
    function replace_link(str, p1)
    {
        p1 = decode(p1)
        if (isSpecial(p1) || isAdvanced(p1) || !reachables.contains(p1))
        {
            return '<a class="unlink" href="">'
        }
        return '<a class="link" href="#wiki_' + encode(p1).replace('%','_') + '">';
    }

    var xmain = get_page(get_var('main_page'));
    var xmenu = get_page('special::edit menu');

    var reachables = set_of_reachables()
    reachables.remove_specials(true).remove(xmain).remove(xmenu)


    var output = [ fieldset( xmain.title, parse(xmain.body).replace(reLink, replace_link)) ]
    
    reachables.iter_pages
    (
        true, 
        function(xpage)
        {
            output.push( fieldset(xpage.title, parse(xpage.body).replace(reLink, replace_link)));
        }
    );

    return generate_webpage(
        "Testing Stikwiki Webpage",
        get_page_style(),
        '',
        parse(xmenu.body).replace(reLink, replace_link),
        output.join('\n')
    );

}

function fieldset(title, body)
{   return '\n\n<div class="fieldset"><a id="wiki_' + encode(title).replace('%','_') +'" ></a>\n'
+ '\t<div class="legend">\n\t\t<h2 class="legend-text">' + title + '</h2>\n\t</div>\n'
+ '<div class="fieldset-body">' + body + '\n</div>\n'
+ '</div>\n\n'
}

// code to generate the base html for the webpage.

function generate_webpage(pagetitle, style, script, menu, body)
{
  var a = [
    'home', 'home', 
  ];

  var s;
  var ss = ""
+'<?xml version="1.0"?>\n'
+'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n'
+'    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n'
+'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"\n>'
+'\n<head>\n'
+'<title>' + pagetitle + '</title>\n\n'
+'<style type="text/css">\n' + style + '\n</style>\n\n'
+'</head>\n\n'
+'<body>\n\n'

+'<table cellspacing="0"><tbody><tr>\n<td style="width: 100%;" valign="bottom">'
+'<p class="title" id="title">Main Page</p></td>\n';

  for (var i=0;i<a.length; i+=2){
	s =  '\n<td class="menu" onclick="' + a[i + 1] + '()">'
	+ '\n<div style="display: block; cursor: pointer;" id="menu_' + a[i] +'">'
	+ '\n<img style="display: block;" id="img_' + a[i] +'" alt="&nbsp;' + a[i] + '&nbsp;" src="files/' + a[i] + '.png" />'
    + '\n<span id="alt_' + a[i] + '" style="display: none; font-family: wingdings; font-size: 24pt;">*</span>'
    + '\n</div></td>\n\n';
	ss += s;
  }
ss += ''
+'</tr></tbody></table><hr />'
+'\n'
+'    <!-- Left Navigation Menu -->\n'
+'    <table style="display: block;" id="text_area" cellspacing="10"><tbody><tr>\n'
+'        <td valign="top">\n'
+'            <div class="menu_area">\n'
+'                <div class="wiki" id="menu_area">\n' + menu + '\n</div>\n'
+'            </div>\n'
+'        </td>\n'
+'    <!-- End of left Navigation menu -->\n'
+'\n'
+'    <!-- Main window -->\n'
+'        <td style="width: 88%;" rowspan="2" valign="top">\n'
            + body
+'        </td>\n'
+'    <!-- End of main window -->\n'
+'\n'
+'    </tr><tr>\n'
+'        <td>&nbsp;</td>\n'
+'\n'   
+'    </tr>\n' 
+'    </tbody></table>\n'
+'<div><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />'
+'<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />'
+'<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>'
+'\n</body></html>\n'
return ss
}

// code to generate the html for the title and main menu for a page.
// must be called in on_load


function setup_menu() {

  var a = [
    'back', 'go_back',
    'forward', 'go_forward',
    'advanced', 'advanced',
    'home', 'home', 
    'edit', 'edit',
    'cancel', 'cancel',
    'save', 'save' ];

  var s;
  var ss =  '\n<table cellspacing="0"><tbody><tr>\n<td style="width: 100%;" valign="bottom">';
      ss += '<p class="title" id="title">Main Page</p></td>';
      ss += '\n';
  for (var i=0;i<a.length; i+=2){
	s =  '\n<td class="menu" onclick="' + a[i + 1] + '()">'
	+ '\n<div style="display: block; cursor: pointer;" id="menu_' + a[i] +'">'
	+ '\n<img style="display: block;" id="img_' + a[i] +'" alt="&nbsp;' + a[i] + '&nbsp;" src="files/' + a[i] + '.png" />'
    + '\n<span id="alt_' + a[i] + '" style="display: none; font-family: wingdings; font-size: 24pt;">*</span>'
    + '\n</div></td>\n\n';
	ss += s;
  }
ss +=
 '</tr></tbody></table><hr />'
+'    <div style="display: none;" id="debug_info">\n'
+'       <i>If you see this text, you\'re using a development version. It won\'t save on disk until you find the line that says </i>\n'
+'        <b><tt>var debug = true;</tt></b>\n'
+'        <i> and change it to </i>\n'
+'        <b><tt>false</tt></b>.\n'
+'        </div>\n'
+'\n'
+'    <div style="display: none;" id="unsupported_browser">\n'
+'        <i>Your browser is not supported. You can access the wiki but you won\'t be able to save. Sorry.</i>\n'
+'    </div>\n'
+'    <!-- Left Navigation Menu -->\n'
+'    <table style="display: block;" id="text_area" cellspacing="10"><tbody><tr>\n'
+'        <td valign="top">\n'
+'            <div class="menu_area">\n'
+'                <div class="wiki" id="menu_area">\n'
+'                    &nbsp;\n'
+'                </div>\n'
+'                <div style="display: block;" id="menu_edit_button">\n'
+'                    <hr>\n'
+'                    <div style="text-align: center;">\n'
+'                        <a class="link" onclick="go_to(\'Special::Edit Menu\')">[Edit]</a>\n'
+'                    </div>\n'
+'                </div>\n'
+'            </div>\n'
+'        </td>\n'
+'    <!-- End of left Navigation menu -->\n'
+'\n'
+'    <!-- Main window -->\n'
+'        <td style="width: 88%;" rowspan="2" valign="top">\n'
+'            <div class="text_area" id="wiki_text">Insert text here.</div>\n'
+'        </td>\n'
+'    <!-- End of main window -->\n'
+'\n'
+'    </tr><tr>\n'
+'        <td>&nbsp;</td>\n'
+'\n'   
+'    </tr>\n' 
+'    </tbody></table>\n'
+'\n'
+'    <!-- Editor -->\n'
+'    <div style="display: none;" id="edit_area">\n'
+'        <div style="display: block;" id="edit_page_title">\n'
+'            Page title: <input id="page_title" type="text">\n'
+'        </div>\n'
+'        <textarea style="width: 986px; height: 433px;" cols="0" rows="0" id="editor">\n'
+'            &nbsp;\n'
+'        </textarea>\n'
+'        <table style="font-size: 8pt;">\n'
+'            <tbody><tr>\n'
+'                <td>[[link]]</td>\n'
+'                <td>[[http://link.com]]</td>\n'
+'                <td>*bold*</td>\n'
+'                <td>+ list</td>\n'
+'                <td>!header</td>\n'
+'                <td>--- (ruler)</td>\n'
+'                <!-- JC - help note for math mode -->\n'
+'                <td>$math mode$</td>\n'
+'            </tr>\n'
+'            <tr>\n'
+'                <td>[[text|link]]</td>\n'
+'                <td>_underline_</td>\n'
+'                <td>/italic/</td>\n'
+'                <td># numbered list</td>\n'
+'                <td>!!subheader</td>\n'
+'                <td><a class="world" onclick="open_table_help()">(tables)</a></td>\n'
+'            </tr>\n'
+'        </tbody></table>\n'
+'    </div>\n';


var node = document.createElement('div');
node.innerHTML = ss;

document.body.insertBefore(node, document.body.firstChild);
}
function open_table_help()
{
    var w = window.open("about:blank", "help", "height=200px, width=350px, menubar=no, toolbar=no, location=no, status=no, dialog=yes");
    w.document.writeln("<html><head><title>Building tables<\/title><\/head><body>");
    w.document.writeln("<u>Building tables:<\/u><br /><br />");
    w.document.writeln("<tt>{|   <\/tt><br />");
    w.document.writeln("<tt>|+ Table Caption<\/tt><br />");
    w.document.writeln("<tt>| *colum 1* || *column 2* || *column 3*<\/tt><br />");
    w.document.writeln("<tt>|-<\/tt><br />");
    w.document.writeln("<tt>| line 2 || [[a link]] || something<\/tt><br />");
    w.document.writeln("<tt>|-<\/tt><br />");
    w.document.writeln("<tt>| line 3 || || more stuff<\/tt><br />");
    w.document.writeln("<tt>|}   <\/tt>");
    w.document.writeln("<\/body><\/html>");
    w.document.close();
}


/////////////////////////////
// stickwiki_loadsave.js
// vim:sw=4:ts=4:sts=4:et:nu:

function saveWebPage(testing)
{


    if(unsupported_browser)
    {
        alert("This browser is not supported and your changes won't be saved on disk.");
    }
    var filename = document.location.toString().split("#")[0];
    filename = filename.replace("file:///", "");
    filename = filename.replace(/%20/g, " ");
    if(navigator.appVersion.indexOf("Win")!=-1)
    {
        filename = filename.replace(/\//g, "\\");
    }
    else
    {
        filename = "/" + filename.replace(/\.[^\.]*$/, '.webpage.html');
    }

    if (debug)
    {
        alert("In DEBUG mode your webpage won't be saved on disk.");
    } 
    var text = create_single_webpage()

    if (debug || testing)
    {
        debug = testing?'TESTING':'DEBUG';
        alert("In " + debug + " mode your webpage won't be saved on disk.");
        return text;
    } 
    else
    {
        if(confirm("Save to file:\n\n" + filename)) 
        {
            saveFile(filename, text);
        }
        return text
    }
}
// save this file
function saveThisFile()
{

    var head = document.getElementsByTagName('HEAD')[0];

    if (debug)
    {
        return;
    } 
    if(unsupported_browser)
    {
        alert("This browser is not supported and your changes won't be saved on disk.");
        return;
    }
    var filename = document.location.toString().split("#")[0];
    filename = filename.replace("file:///", "");
    filename = filename.replace(/%20/g, " ");
    if(navigator.appVersion.indexOf("Win")!=-1)
    {
        filename = filename.replace(/\//g, "\\");
    }
    else
    {
        filename = "/" + filename;
    }
    saveFile(filename,
        '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"\n'
        + '"http://www.w3.org/TR/html4/loose.dtd">\n'
        + '\n<html>\n<head>'
        + head.innerHTML
        + '</head>\n\n<body id="body">\n\n<div id="wiki" style="display:none">'
        + el('wiki').innerHTML
        + '</div>\n'
        + '\n<div id="variables" style="display:none">'
        + el('variables').innerHTML
        + "</div>\n\n</html>\n"
    );
}

// Copied from TiddyWiki
function saveFile(fileUrl, content)
{
    var r = null;
    r = mozillaSaveFile(fileUrl, content);
    if((r === null) || (r === false))
    {
        r = ieSaveFile(fileUrl, content);
    }
    if((r === null) || (r === false))
    {
        r = operaSaveFile(fileUrl, content);
    }
    return(r);
}

function loadFile(filePath)
{
    var r = null;
    r = mozillaLoadFile(filePath);
    if((r === null) || (r === false))
    {
        r = ieLoadFile(filePath);
    }
    if((r === null) || (r === false))
    {
        r = operaLoadFile(filePath);
    }
    return(r);
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function ieSaveFile(filePath, content)
{
    try
    {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
    }
    catch(e)
    {
        return(null);
    }
    var file = fso.OpenTextFile(filePath,2,-1,0);
    file.Write(content);
    file.Close();
    return(true);
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function ieLoadFile(filePath)
{
    try
    {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var file = fso.OpenTextFile(filePath,1);
        var content = file.ReadAll();
        file.Close();
    }
    catch(e)
    {
        //alert("Exception while attempting to load\n\n" + e.toString());
        return(null);
    }
    return(content);
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function mozillaLoadFile(filePath)
{
    if(window.Components)
    {
        try
        {
            netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
            var file = Components.classes["@mozilla.org/file/local;1"]
                .createInstance(Components.interfaces.nsILocalFile);
            file.initWithPath(filePath);
            if (!file.exists())
            {
                return(null);
            }
            var inputStream = Components.classes["@mozilla.org/network/file-input-stream;1"]
                .createInstance(Components.interfaces.nsIFileInputStream);
            inputStream.init(file, 0x01, 4, null);

            var sInputStream = Components.classes["@mozilla.org/scriptableinputstream;1"]
                .createInstance(Components.interfaces.nsIScriptableInputStream);
            sInputStream.init(inputStream);

            return(sInputStream.read(sInputStream.available()));
        }
        catch(e)
        {
            alert("Exception while attempting to load\n\n" + e);
            return(false);
        }
    }
    return(null);
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function mozillaSaveFile(filePath, content)
{
    if(window.Components)
    {
        try
        {
            netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
            var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
            file.initWithPath(filePath);
            if (!file.exists())
            {
                file.create(0, 6*64 + 6*8 + 4);
            }
            var out = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
            out.init(file, 0x20 | 0x02, 4,null);
            out.write(content, content.length);
            out.flush();
            out.close();
            return(true);
        }
        catch(e)
        {
            return(false);
        }
    }
    return(null);
}

function operaUrlToFilename(url)
{
    var f = "//localhost";
    if(url.indexOf(f) === 0)
    {
        return url.substring(f.length);
    }
    var i = url.indexOf(":");
    if(i > 0)
    {
        return url.substring(i-1);
    }
    return url;
}

function operaLoadFile(filePath)
{
    var content = [];
    try
    {
        var r = new java.io.BufferedReader(new java.io.FileReader(operaUrlToFilename(filePath)));
        var line;
        while ((line = r.readLine()) !== null)
        {
            content.push(new String(line));
        }
        r.close();
    }
    catch(e)
    {
        if(window.opera)
        {
            opera.postError(e);
        }
        return null;
    }
    return content.join("\n");
}

function operaSaveFile(filePath, content)
{
    try
    {
        var s = new java.io.PrintStream(new java.io.FileOutputStream(operaUrlToFilename(filePath)));
        s.print(content);
        s.close();
    }
    catch(e)
    {
        if(window.opera)
        {
            opera.postError(e);
        }
        return null;
    }
    return true;
}

</script>

 <style type="text/css">

/* background */
body {
    background-color: #FAFAFA;
}

/* page title */
p.title {
  font-size: 22pt;
  font-weight: bold;
  margin-bottom: 0pt;
  margin-top: 0pt;
  color: pink;
}

/* Text */
/*
.text_area {
  font-family: "Arial";
} */

/* Left menu */
div.menu_area {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  font-size: 9pt;
  background-color: white;
  padding: 5pt;
  width: 80pt;
}

/* Main text */
div.text_area {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  background-color: white;
  padding: 10pt;
}
    
/* existent link */
a.link {
  color: blue;
}
a.link:hover {
  text-decoration: underline;
  cursor:pointer;
}

/* unexistent link */
a.unlink {
  color: red;
}
a.unlink:hover {
  text-decoration: underline;
  cursor:pointer;
}

/* outside world link */
a.world {
  color: darkgreen;
  text-decoration: underline;
}
a.world:hover {
  cursor:pointer;
}

/* Tables */
table.text_area {
  border-color: black;
  border-spacing: 0px;
  border-style: solid;
  border-width: 1px;
}

table.text_area td {
  border-width: 1px;
  border-style: solid;
  padding: 5px;
}

/* webpage */

.legend {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  padding: 0px;
  margin-bottom: 1em;
  
}
.legend-text {
    padding: 0px;
    margin: 0px;
    padding-left: 1em;
    background-color: thistle;
}

div.fieldset {
  padding-bottom: 2em;
}

div.fieldset-body {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  background-color: white;
  padding: 10pt;
}

 </style><!-- End CSS code --></head>

<body id="body">

<div id="wiki" style="display:none">  

        
<!-- SPECIAL -->

        <div id="Special%3A%3AEdit%20Menu">%5B%5BFront%20Page%5D%5D%0A%5B%5BAdvanced%7CSpecial%3A%3AAdvanced%5D%5D%0A---%0A%5B%5BTo%20Do%5D%5D%0A%5B%5Btable%5D%5D%0A---%0A%5B%5BEdit%20CSS%7CSpecial%3A%3AEdit%20CSS%5D%5D%0A%5B%5BBack%20Links%7CSpecial%3A%3ABack%20Links%5D%5D%0A%5B%5BShow%20Parsed%20Text%7CSpecial%3A%3AShow%20Parsed%20Text%5D%5D%0A%5B%5BCreate%20Webpage%7CSpecial%3A%3AExport%20Single%20Webpage%5D%5D</div>

<div id="Special%3A%3AAdvanced">%21Queries%20%0A%20%20%5B%5BMain%20Page%7CSpecial%3A%3AMain%20Page%5D%5D%3A%20the%20main%20page%20in%20the%20wiki%2C%20whatever%20that%20page%20is%20called.%0A%0A%20%20%5B%5BAll%20Pages%7CSpecial%3A%3AAll%20Pages%5D%5D%3A%20a%20list%20of%20all%20pages%20in%20this%20wiki.%0A%0A%20%20%5B%5BPages%20not%20yet%20created%7CSpecial%3A%3APages%20not%20yet%20created%5D%5D%3A%20a%20list%20of%20pages%20that%20have%20links%20to%20them%2C%20but%20were%20still%20not%20created.%20%0A%0A%20%20%5B%5BOrphaned%20Pages%7CSpecial%3A%3AOrphaned%20Pages%5D%5D%3A%20a%20list%20of%20pages%20that%20can%20not%20be%20reached%20through%20links%20from%20the%20%5B%5BMain%20Page%7CSpecial%3A%3AMain%20Page%5D%5D%20or%20the%20%5B%5BSide%20Menu%7Cspecial%3A%3AEdit%20menu%5D%5D.%0A%0A%20%20%5B%5BBack%20Links%7CSpecial%3A%3ABack%20Links%5D%5D%3A%20a%20list%20of%20pages%20that%20have%20links%20to%20the%20current%20page.%0A%0A%21Visual%20%0A%20%20%5B%5BEdit%20CSS%7CSpecial%3A%3AEdit%20CSS%5D%5D%3A%20edit%20the%20CSS%20that%20controls%20the%20look%20of%20the%20wiki%20to%20be%20edited%20dynamically.%0A%0A%20%20%5B%5BEdit%20Menu%7Cspecial%3A%3AEdit%20menu%5D%5D%3A%20edit%20the%20contents%20of%20the%20side%20menu.%0A%0A%20%20%5B%5BShow%20Parsed%20Text%7CSpecial%3A%3Ashow%20parsed%20text%5D%5D%3A%20veiw%20the%20actual%20%28x%29html%20code%20produced%20by%20the%20wiki%20parser%20for%20the%20current%20page.%0A%0A%21Controls%0A%20%20%5B%5BBlock/Unblock%20edits%7CSpecial%3A%3ABlock%20Edits%5D%5D%3A%20hides%20the%20edit%20button%2C%20to%20be%20used%20when%20this%20wiki%20goes%20public%20%28when%20used%20as%20a%20webpage%2C%20for%20example%29%0A%0A%20%20%5B%5BExport%20as%20Single%20Webpage%7CSpecial%3A%3AExport%20Single%20Webpage%5D%5D%0A%0A%21Last%20Modified%3A%20%3Cspan%20id%3D%22lastDate%22%3E%5Berror%5D%3C/span%3E.</div>

<!-- WIKI -->
<div id="test_zero">+%20muy%20list%0A+%20sdds%0A+%20ds%20dssd%20+hello%0A+%20dsssd</div>

<div id="test">Insert text here.</div>

<div id="test%2Cone">%5B%5BPage%201%5D%5D%0A%0A%0A%5B%5Btable%5D%5D</div>

<div id="test%20Page">Insert%20text%20here.</div><div id="Main%20Page">Insert%20text%20here.</div>





<div id="Page%201">Insert%20text%20here.</div><div id="table">%7B%7C%0A%7C+%20Table%20Caption%0A%7C%20*colum%201*%20%7C%7C%20*column%202*%20%7C%7C%20*column%203*%0A%7C-%0A%7C%20line%202%20%7C%7C%20%5B%5Ba%20link%5D%5D%20%7C%7C%20something%0A%7C-%0A%7C%20line%203%20%7C%7C%20%7C%7C%20more%20stuff%0A%7C%7D%20</div><div id="To%20Do">What%20to%20do%20%20%20d</div><div id="Front%20Page">%21Wiki%20on%20a%20Stick%20Example%0A%21%21Formatting%0A%0A/%28click%20on%20the%20pencil%20icon%20on%20the%20top%20right%20corner%20to%20see%20source%29/%0A%0A%5B%5BTo%20Do%5D%5D%0AExternal%20links%3A%20%5B%5BWiki%20on%20a%20Stick%7Chttp%3A//stickwiki.sourceforge.net/%5D%5D%0A%0A/damn%5C/path/file%3A///home/bob/work/stickwiki/files/save.png%0A%0A%0A%0ABoldface%3A%20*Boldface%20text*%0AItalics%3A%20/italics%20text/%0AUnderline%3A%20_underlined%5C_text_%0A%0ARuler%3A%0A---%0A%0AList%3A%0A+%20Item%201%0A++%20Subitem%20a%0A++%20Subitem%20b%0A+%20Item%202%0A++%20Subitem%20c%0A+++%20Subsubitem%20d%0A+%20Item%203%0A%0ANumbered%20list%3A%0A%23%20Item%20A%0A%23%23%20Subitem%20i%0A%23%23%20Subitem%20ii%0A%23%20Item%20B%0A%23%23%20Subitem%20iii%0A%23%23%23%20Subsubitem%20iv%0A%23%20Item%20C%0A%0A%21%21Tables%0A%0A%7B%7C%20width%3D%2290%25%22%0A%7C+%20Telephone%20Table%0A%7C%20*Column%20Name*%20%7C%7C%20*Type*%20%7C%7C%20*Other*%20%7C%7C%20*Description*%0A%7C-%0A%7C%20id%20%7C%7C%20INT%20%7C%7C%20PRIMARY%20KEY%20%7C%7C%20Row%20ID%0A%7C-%0A%7C%20contact%20id%20%7C%7C%20INT%20%7C%7C%20KEY%20%7C%7C%20References%20FOREIGN%20KEY%28Contacts.id%29%0A%7C-%0A%7C%20type%20%7C%7C%20ENUM%28%27Home%27%2C%27Work%27%2C%27Mobile%27%2C%27Pager%27%2C%27Other%27%29%20%7C%7C%20%7C%7C%20Defines%20type%20of%20Telephone%20record%0A%7C-%0A%7C%20number%20%7C%7C%20CHAR%2832%29%20%7C%7C%20%7C%7C%20Contains%20actual%20Telephone%20number%0A%7C%7D</div></div>

<div id="variables" style="display:none">
        <div id="main_page_">Front%20Page</div>
        <div id="version_">0.04</div>
        <div id="permit_edits_">1</div>
    </div>

</html>
